

bool art-data::unrand_art_handle()
{
  if (weapon && is_unrandom_artefact(*weapon, UNRAND_DEVASTATOR)
              && you.can_see(*defender))
          {

              targeter_smite hitfunc(attacker, 1, 1, 1, false);
              hitfunc.set_aim(defender->pos());

              if (stop_attack_prompt(hitfunc, "attack", nullptr, nullptr,
                                     defender->as_monster()))
              {
                  cancel_attack = true;
                  return false;
              }
          }
          else if (weapon &&
                  ((is_unrandom_artefact(*weapon, UNRAND_SINGING_SWORD)
                    && !silenced(you.pos()))
                   || is_unrandom_artefact(*weapon, UNRAND_VARIABILITY))
                   && you.can_see(*defender))
          {
              targeter_radius hitfunc(&you, LOS_NO_TRANS);

              if (stop_attack_prompt(hitfunc, "attack",
                                     [](const actor *act)
                                     {
                                         return !god_protects(act->as_monster());
                                     }, nullptr, defender->as_monster()))
              {
                  cancel_attack = true;
                  return false;
              }
          }
          else if (weapon && is_unrandom_artefact(*weapon, UNRAND_TORMENT)
                   && you.can_see(*defender))
          {
              targeter_radius hitfunc(&you, LOS_NO_TRANS);

              if (stop_attack_prompt(hitfunc, "attack",
                                     [] (const actor *m)
                                     {
                                         return !m->res_torment();
                                     },
                                     nullptr, defender->as_monster()))
              {
                  cancel_attack = true;
                  return false;
              }
          }
          else if (weapon && is_unrandom_artefact(*weapon, UNRAND_ARC_BLADE)
                   && you.can_see(*defender))
          {
              vector<const actor *> exclude;
              if (!safe_discharge(defender->pos(), exclude))
              {
                  cancel_attack = true;
                  return false;
              }
          }
          else if (weapon && is_unrandom_artefact(*weapon, UNRAND_POWER)
                   && you.can_see(*defender))
          {
              targeter_beam hitfunc(&you, 4, ZAP_SWORD_BEAM, 100, 0, 0);
              hitfunc.beam.aimed_at_spot = false;
              hitfunc.set_aim(defender->pos());

              if (stop_attack_prompt(hitfunc, "attack",
                                     [](const actor *act)
                                     {
                                         return !god_protects(act->as_monster());
                                     }, nullptr, defender->as_monster()))
              {
                  cancel_attack = true;
                  return false;
              }
          }
}        
